<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>reveal.js</title>

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/sky.css">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<section>
                    <h1>"table" in lua 5.2</h1>
                </section>

                <section>
                    <h2>Outline</h2>
                    <ul>
                        <li>Basic of lua "table"</li>
                        <li>Adapt lua "table" for multiple data structure</li>
                        <li>Dive into lua "table" source code</li>
                    </ul>
                </section>

				<section>
                    <h2>Overview of lua</h2>
                    <ul>
                        <li>dynamically-type: types are attached to values rather than to variables.</li>
                        <li>basic types (first-class):
                        <ol>
                            <li>nil (like "None" in Python, including undefined variables)</li>
                            <li>boolean: true, false</li>
                            <li>number: double-precision floating-point numbers (like "double" in C)</li>
                            <li>string: immutable (once internalized, cannot be changed)</li>
                            <li>table: associative arrays</li>
                            <li>function: Lua functions, C functions</li>
                            <li>heavy userdata</li>
                            <li>light userdata</li>
                            <li>thread: coroutines</li>
                        </ol>
                        </li>
                    </ul>

					<aside class="notes">
					</aside>
                </section>

				<section>
                    <h2>Overview of table in lua</h2>
                    <ul>
                        <li>Tables are the main — in fact, the only — data-structuring mechanism in Lua.</li>
                        <li>Tables in Lua are associative arrays, that is, they can be indexed by any value (except nil) and can hold values of any type.</li>
                        <li>Tables are dynamic in the sense that they may grow when data is added to them (by assigning a value to a hitherto non-existent field) and shrink when data is removed from them (by assigning nil to a field).</li>
                    </ul>

					<aside class="notes">
					</aside>
                </section>

                <section>
                    <section>
                        <h2>Basic</h2>
                    </section>

                    <section>
                        <h3>Table Creation</h3>
                        <pre><code class="lua" data-trim>
-- Empty table
local t1 = {}

-- Table as an array
local t2 = { 1, 2, "str", t1 }

-- Table as a hashtable
local t3 = {
    ["k1"] = "v1",
    k2 = "v2",
}

-- Table as mixed data structure of array and hashtable
local t4 = {
    "e1",           -- stored in the array part
    ["k1"] = "v1",  -- stored in the hash part
    k2 = "v2",      -- stored in the hash part
}
                        </code></pre>
                    </section>

                    <section>
                        <h3>Table As An Array</h3>
                        <p>Array Operations:</p>
                        <br>
                        <ul>
                            <li>Set the element of position "n"</li>
                            <li>Get the element of position "n"</li>
                            <li>Get the number of elements</li>
                            <li>Iterate over all elements</li>
                            <li>Delete the element of position "n"</li>
                        </ul>
                    </section>

                    <section>
                        <h4>Table As An Array: Setter</h4>
                        <p>Set the element of position "n"</p>

                        <blockquote>
                            NOTE: index in lua starts from 1
                        </blockquote>

                        <pre><code class="lua" data-trim>
-- Way #1: specify the index
local t = {}
t[1] = "e1"
t[2] = "e2"
t[3] = "e3"
t[4] = "e4"
                        </code></pre>

                        <pre><code class="lua" data-trim>
-- Way #2: use table.insert (list, [pos,] value)
local t = {}
table.insert(t, 1, "e1")
table.insert(t, 2, "e2")
-- table.insert(t, x) inserts x at the end of list t
table.insert(t, "e3")
table.insert(t, "e4")
                        </code></pre>

                        <p>See the <a href="https://www.lua.org/manual/5.2/manual.html#pdf-table.insert">manual of table.insert</a></p>
                    </section>

                    <section>
                        <h4>Table As An Array: Getter</h4>
                        <p>Get the element of position "n"</p>

                        <pre><code class="lua" data-trim>
local t = {"e1", "e2", "e3", "e4"}
-- Get the fourth element
print(t[4])

--[[
Output:
e4
]]
                        </code></pre>
                    </section>

                    <section>
                        <h4>Table As An Array: Get element number</h4>
                        <p>Get the number of elements</p>

                        <pre><code class="lua" data-trim>
local t = {"e1", "e2", "e3", "e4"}

-- Way #1: the length operator "#"
print(#t)

--[[
Output:
4
]]

-- Way #2
--[[
table.unpack(t) returns "e1", "e2", "e3", "e4"
so it becomes:
print(select('#', "e1", "e2", "e3", "e4"))
]]
print(select('#', table.unpack(t)))
                        </code></pre>

                        <p>Refer to </p>
                        <ul>
                            <li><a href="https://www.lua.org/manual/5.2/manual.html#3.4.6">manual of the length operator "#"</a></li>
                            <li><a href="https://www.lua.org/manual/5.2/manual.html#pdf-select">manual of select</a></li>
                            <li><a href="https://www.lua.org/manual/5.2/manual.html#pdf-table.unpack">manual of table.unpack</a></li>
                        </ul>
                    </section>

                    <section>
                        <h4>Table As An Array: Iteration</h4>
                        <p>Iterate over all elements</p>

                        <pre><code class="lua" data-trim>
local t = {"e1", "e2", "e3", "e4"}

-- Forward iteration
for i = 1, 4 do
    print(t[i])
end

--[[
Output:
e1
e2
e3
e4
]]

-- More general way:
for i = 1, #t do
    print(t[i])
end

--[[
Output:
e1
e2
e3
e4
]]

-- Backward iteration: 
-- for i = start, end, step do
-- end
for i = #t, 1, -1 do
    print(t[i])
end


--[[
Output:
e4
e3
e2
e1
]]
                        </code></pre>

                        <p>There's another way of using an <b>iterator</b>. We will talk about that later.</p>
                    </section>

                    <section>
                        <h4>Table As An Array: Delete</h4>
                        <p>Delete the element of position "n"</p>

                        <pre><code class="lua" data-trim>
-- Way #1: set the specified element as nil
local t = {"e1", "e2", "e3", "e4"}

-- Delete the third element
t[3] = nil

--[[
NOTE:
1. lua table will not pack the elements backward to fill the empty slot
2. the number of elements will not change
]]
print("The number of elements:", #t)
for i = 1, #t do
    print(t[i])
end

--[[
Output:
The number of elements: 4
e1
e2
nil
e4
]]
                        </code></pre>
                    </section>

                    <section>
                        <h4>Table As An Array: Delete</h4>
                        <p>Delete the element of position "n"</p>

                        <pre><code class="lua" data-trim>
-- Way #2: use table.remove (list [, pos])
local t = {"e1", "e2", "e3", "e4"}

table.remove(t, 3)
print("The number of elements:", #t)
for i = 1, #t do
    print(t[i])
end

--[[
Output:
The number of elements: 3
e1
e2
e4
]]

table.remove(t)
print("The number of elements:", #t)
for i = 1, #t do
    print(t[i])
end

--[[
Output:
The number of elements: 2
e1
e2
]]
                        </code></pre>

                        <p>See the <a href="https://www.lua.org/manual/5.2/manual.html#pdf-table.delete">manual of table.delete</a></p>
                    </section>

                    <section>
                        <h4>Table As An Array: Delete</h4>
                        <p>Common misuse of table.delete in loop</p>

                        <pre><code class="lua" data-trim>
local t = {1, 2, 3, 4}

for i = 1, #t do
    if t[i] < 4 then
        table.remove(t, i)
    end
end

--[[
Opps...
lua: xxx.lua:4: attempt to compare nil with number
stack traceback:
        xxx.lua:4: in main chunk
        [C]: in ?

]]
                        </code></pre>

                    </section>

                    <section>
                        <h4>Table As An Array: Delete</h4>
                        <p>Straightforward solution: use backward iteration</p>

                        <pre><code class="lua" data-trim>
local t = {1, 2, 3, 4}

for i = #t, 1, -1 do
    if t[i] < 4 then
        table.remove(t, i)
    end
end

for i = 1, #t do
    print(t[i])
end

--[[
Output:
4
]]
                        </code></pre>

                        <p>We will see another misuse case of table.remove when we discuss iterator ;)</p>
                    </section>

                    <section>
                        <h3>Table As A Hashtable</h3>
                        <p>Hashtable Operations:</p>
                        <br>
                        <ul>
                            <li>Set the value of key "k"</li>
                            <li>Get the value of key "k"</li>
                            <li>Delete the value of key "k"</li>
                            <li>Iterate over all key-value pairs</li>
                            <li>Get the number of key-value pairs</li>
                        </ul>
                    </section>

                    <section>
                        <h4>Table As A Hashtable: Setter</h4>

                        <pre><code class="lua" data-trim>
local t = {}

-- Way #1
t["key"] = "value"

-- Way #2: syntactic sugar
t.key = "value"

-- Compare with the following code:
local key = "key"
t[key] = "value"
                        </code></pre>
                    </section>

                    <section>
                        <h4>Table As A Hashtable: Setter</h4>

                        <pre><code class="lua" data-trim>
local t = {
    "key" = "value",
}

print("t[\"key\"] = ", t["key"])
print("t.key = ", t.key)

local k = "key"
print("t[k] = ", t[k])
-- t.k is equivalent to t["k"]
print("t.k = ", t.k)

--[[
Output:
t["key"] =      value
t.key =         value
t[k] =  value
t.k =   nil
]]
                        </code></pre>
                    </section>

                    <section>
                        <h4>Table As A Hashtable: Delete</h4>

                        <pre><code class="lua" data-trim>
local t = {
    "key" = "value",
}

t.key = nil
                        </code></pre>
                    </section>

                    <section>
                        <h4>Table As A Hashtable: Iteration</h4>

                        <p>Meet "next (table [, index])"</p>

                        <blockquote>
                            <p style="font-size: 18px;">Allows a program to traverse all fields of a table. Its first argument is a table and its second argument is an index in this table. next returns the next index of the table and its associated value. When called with nil as its second argument, next returns an initial index and its associated value. When called with the last index, or with nil in an empty table, next returns nil. If the second argument is absent, then it is interpreted as nil. In particular, you can use next(t) to check whether a table is empty.</p>
                        </blockquote>

                        <pre><code class="lua" data-trim>
local t = {
    k1 = "v1",
    k2 = "v2",
    k3 = "v3",
}

local k, v
-- Note: equivalent to:
-- local k = nil
-- local v = nil
for i = 1, 3 do
    k, v = next(t, k)
    print(k, v)
end

-- NOTE: The order in which the indices are enumerated is not specified, even for numeric indices.
--[[
Output:
k1      v1
k3      v3
k2      v2
]]
                        </code></pre>

                        <p>See the <a href="https://www.lua.org/manual/5.2/manual.html#pdf-next">manual of next</a></p>
                    </section>

                    <section>
                        <h4>Table As A Hashtable: Iteration</h4>
                        <p>What if we don't know there's three key-value pairs in the table `t`?</p>

                        <pre><code class="lua" data-trim>
local t = {
    k1 = "v1",
    k2 = "v2",
    k3 = "v3",
}

local k, v = next(t, k)
while k do
-- Note: equivalent to:
-- while k ~= nil do
    print(k, v)
    k, v = next(t, k)
end

--[[
Output:
k2      v2
k1      v1
k3      v3
]]
                        </code></pre>
                    </section>

                    <section>
                        <h4>Iterator</h4>
                        <p>More advance: meet "generic for" in lua</p>

                        <pre><code class="lua" data-trim>
for {var-list} in {exp-list} do
    {body}
end
                        </code></pre>

                        <p>We can write an iterator and use it in the generic for loop!</p>
                    </section>

                    <section>
                        <h4>Iterator</h4>
                        <p>Hand-written iterator (V1):</p>

                        <pre><code class="lua" data-trim>
local t = {
    k1 = "v1",
    k2 = "v2",
    k3 = "v3",
}

local function iter(t)
    local last_k
    return function()
        local v
        last_k, v = next(t, last_k)
        return last_k, v
    end
end

-- Use the iterator in the generic for loop
for k, v in iter(t) do
    print(k, v)
end

--[[
Output:
k3      v3
k2      v2
k1      v1
]]

-- Use the iterator to rewrite the previous while loop
local producer = iter(t)
local k, v = producer()
while k do
    print(k, v)
    k, v = producer()
end

--[[
Output:
k3      v3
k2      v2
k1      v1
]]
                        </code></pre>

                        <p>It would be difficult to understand if you don't know anything about closure or lambda! :(</p>
                    </section>

                    <section>
                        <h4>Iterator</h4>
                        <p>Hand-written iterator (V2): 
                        we can pass a function and its parameters in {exp-list} of "generic for".
                        </p>

                        <pre><code class="lua" data-trim>
local t = {
    k1 = "v1",
    k2 = "v2",
    k3 = "v3",
}

for k, v in next, t do
    print(k, v)
end

--[[
Output:
k3      v3
k2      v2
k1      v1
]]
                        </code></pre>

                        <ul>
                            <li>Simpler code :)</li>
                            <li>It would still be difficult to understand if you don't know functions in lua are first-class variables! :(</li>
                        </ul>
                    </section>

                    <section>
                        <h4>Iterator</h4>
                        <p>There's a built-in iterator: "pairs"! XD</p>

                        <pre><code class="lua" data-trim>
local t = {
    k1 = "v1",
    k2 = "v2",
    k3 = "v3",
}

for k, v in pairs(t) do
    print(k, v)
end

--[[
Output:
k3      v3
k1      v1
k2      v2
]]
                        </code></pre>

                        <p>See the <a href="https://www.lua.org/manual/5.2/manual.html#pdf-pairs">manual of pairs</a></p>
                    </section>

                    <section>
                        <h4>Iterator</h4>
                        <p>There's another built-in iterator for array: "ipairs"! XD</p>

                        <pre><code class="lua" data-trim>
local t = {"e1", "e2", "e3", "e4"}

-- Only forward iteration
for i, v in ipairs(t) do
    print(i, v)
end

--[[
Output:
1       e1
2       e2
3       e3
4       e4
]]
                        </code></pre>

                        <p>See the <a href="https://www.lua.org/manual/5.2/manual.html#pdf-ipairs">manual of ipairs</a></p>
                    </section>

                    <section>
                        <p>Another common misuse of table.delete in loop</p>

                        <pre><code class="lua" data-trim>
local t = {1, 2, 3, 4}

for i, v in ipairs(t) do
    print("Access the element: ", v)
    if v < 4 then
        table.remove(t, i)
    end
end

print("Result:")
for i, v in ipairs(t) do
    print(i, v)
end

--[[
Output:
Access the element:     1
Access the element:     3
Result:
1       2
2       4
]]
                        </code></pre>
                    </section>

                    <section>
                        <h4>Table As A Hashtable: Get the Number of key-value Pairs</h4>

                        <pre><code class="lua" data-trim>
local t = {
    k1 = "v1",
    k2 = "v2",
    k3 = "v3",
}

-- Try the length operator "#":
print(#t)

--[[
Output:
0
]]
                        </code></pre>

                        <p>The length operator "#" only deals with the array part of table. :(</p>
                    </section>

                    <section>
                        <h4>Table As A Hashtable: Get the Number of key-value Pairs</h4>
                        <p>Since we know how to iterator over the table, we know how to count all the key-value pairs. :)</p>

                        <pre><code class="lua" data-trim>
local t = {
    k1 = "v1",
    k2 = "v2",
    k3 = "v3",
}

local cnt = 0
for i, v in pairs(t) do
    cnt = cnt + 1
end

print(cnt)

--[[
Output:
3
]]
                        </code></pre>

                        <p>Complexity: O(N)</p>
                    </section>

                </section>

                <section>
                    <section>
                        <h2>Data Structure</h2>
                    </section>

                    <section>
                        <h3>Matrices / Multi-Dimensional Arrays</h3>

                        <p>Like C array:</p>

                        <pre><code class="lua" data-trim>
-- Create a matrix of zeros with dimensions N by M

-- Way #1
mt = {}             -- create the matrix
for i = 1, N do
    mt[i] = {}      -- create a new row
    for j = 1, M do
        mt[i][j] = 0
    end
end

-- Way #2
mt = {}             -- create the matrix
for i = 1, N do
    for j = 1, M do
        mt[i*M + j] = 0
    end
end
                        </code></pre>
                    </section>

                    <section>
                        <h3>Linked Lists</h3>

                        <pre><code class="lua" data-trim>
                        </code></pre>
                    </section>

                    <section>
                        <h3>Stack</h3>

                        <pre><code class="lua" data-trim>
                        </code></pre>
                    </section>

                    <section>
                        <h3>Queues and Double Queues</h3>

                        <pre><code class="lua" data-trim>
local List = {}

function List.new()
    return {first = 0, last = -1}
end

function List.pushleft(list, value)
    local first = list.first - 1
    list.first = first
    list[first] = value
end

function List.pushright(list, value)
    local last = list.last + 1
    list.last = last
    list[last] = value
end

function List.popleft(list)
    local first = list.first
    if first > list.last then error("list is empty") end
    local value = list[first]
    list[first] = nil        -- to allow garbage collection
    list.first = first + 1
    return value
end

function List.popright(list)
    local last = list.last
    if list.first > last then error("list is empty") end
    local value = list[last]
    list[last] = nil         -- to allow garbage collection
    list.last = last - 1
    return value
end
                        </code></pre>
                    </section>

                    <section>
                        <h3>Sets</h3>

                        <pre><code class="lua" data-trim>
local Set = {}

function Set.new()
    return {}
end

function Set.add(set, element)
    set[element] = true
end

function Set.has(set, element)
    return set[element]
end

-- Union of two sets
function Set.union(set1, set2)
    local union = {}
    for _, set in ipairs({set1, set2}) do
        for k, _ in pairs(set) do
            union[k] = true
        end
    end
    return union
end

--[[
For advanced lua user, you can write a more general function for set union.
e.g.

function Set.union(...)
    local union = {}
    for _, set in ipairs({...}) do
        for k, _ in pairs(set) do
            union[k] = true
        end
    end
    return union
end
]]

-- Intersection of two sets
function Set.intersect(set1, set2)
    local intersect = {}
    for k, _ in pairs(set1) do
        intersect[k] = set2[k]
    end
    return intersect
end

--[[
For advanced lua user, you can write a more general function for set intersection.
e.g.

-- This is a naive version of counting elements:

function Set.intersect(...)
    local intersect = {}
    local set_list = {...}
    for _, set in ipairs(set_list) do
        for k, _ in pairs() do
            if intersect[k] then
                intersect[k] = intersect[k] + 1
            else
                intersect[k] = 1
            end
        end
    end

    local num_of_set = #set_list
    for k, num in pairs(intersect) do
        if num < num_of_set then
            intersect[k] = nil
        else
            intersect[k] = true
        end
    end

    return intersect
end

-- This is a better version:

function Set.intersect(...)
    local intersect = {}
    local set_list = {...}
    local first_set = set_list[1]
    local num_of_set = #set_list
    for k, _ in pairs(first_set) do
        intersect[k] = true
        for i = 2, num_of_set do
            local set = set_list[i]
            -- equivalent to: 
            -- set[k] == nil or set[k] == false
            if not set[k] then
                intersect[k] = nil
                break
            end
        end
    end
    return intersect
end
]]
                        </code></pre>
                    </section>

                    <section>
                        <h2></h2>
                        <p>
                        </p>
                    </section>

                    <section>
                        <h2></h2>
                        <p>
                        </p>
                    </section>

                    <section>
                        <h2></h2>
                        <p>
                        </p>
                    </section>

                    <section>
                        <h2></h2>
                        <p>
                        </p>
                    </section>

                    <section>
                        <h2></h2>
                        <p>
                        </p>
                    </section>

                </section>

                <section>
                    <section>
                        <h2>Dive into lua Source Code</h2>
                        <p>I will omit some code for simplicity. XD</p>
                    </section>

                    <section>
                        <h3>How do lua store table?</h3>
                    </section>

                    <section>
                        <h4>How do lua store table?</h4>

                        <p>Definition in lobject.h:</p>

                        <pre><code class="c" data-trim>
typedef struct Table {
  lu_byte lsizenode;  /* log2 of size of `node' array */
  TValue *array;  /* array part */
  Node *node;
  Node *lastfree;  /* any free position is before this position */
  int sizearray;  /* size of `array' array */
} Table;
                        </code></pre>

                        <p>lobject.c - some generic functions over Lua objects.</p>

                    </section>

                    <section>
                        <h4>What does `Table` contain?</h4>
                        <ul>
                            <li>A `Table` instance has at lease three continued areas in memory:
                            <ul>
							<img align="middle" data-src="img/Table-simple.png">
                                <li>The `Table` instance itself.</li>
                                <li>`array`: array part of `Table`</li>
                                <li>`node`: hashtable part of `Table`</li>
                            </ul>

                            </li>
                            <li>Fields of recording the size:
                            <ul>
                                <li>size of array part: `sizearray`</li>
                                <li>size of hashtable part: 2^`lsizenode`</li>
                                <pre><code class="c" data-trim>
#define twoto(x)    (1<<(x))
#define sizenode(t) (twoto((t)->lsizenode))
                                </code></pre>
                            </ul>
                            </li>
                        </ul>
                    </section>

                    <section>
                        <p>Macros related to `Table`:</p>
                        <pre><code class="c" data-trim>
#define gnode(t,i)  (&(t)->node[i])
                        </code></pre>
                    </section>

                    <section>
                        <h4>What is `Node`?</h4>

                        <pre><code class="c" data-trim>
typedef struct Node {
  TValue i_val;
  TKey i_key;
} Node;
                        </code></pre>

                        <p>`Node` is the structure for key-value pair</p>
                    </section>

                    <section>
                        <p>Macros related to `Node`:</p>
                        <pre><code class="c" data-trim>
#define gval(n)     (&(n)->i_val)
                        </code></pre>
                    </section>

                    <section>
                        <h4>What is `TValue` then?</h4>

                        <pre><code class="c" data-trim>
typedef struct lua_TValue TValue;

/*
** Tagged Values. This is the basic representation of values in Lua,
** an actual value plus a tag with its type.
*/

struct lua_TValue {
  Value value_;
  int tt_;
};
                        </code></pre>

                        <p>`TValue` = Tagged Value</p>
                        <ul>
                            <li>`TValue` contains the value and a type tag</li>
                            <li>Lua represents values as tagged unions, that is, as pairs (t, v), where t is an integer tag identifying the type of the value v, which is a union of C types implementing Lua types.</li>
                            <li>omitted source code: NaN Trick</li>
                        </ul>
                    </section>

                    <section>
                        <p>Macros related to `TValue`:</p>
                        <pre><code class="c" data-trim>
#define val_(o)     ((o)->value_)

/* raw type tag of a TValue */
#define rttype(o)   ((o)->tt_)
                        </code></pre>
                    </section>

                    <section>
                        <h4>How does the tag distinguish different types of lua value?</h4>

                        <p>lua.h</p>
                        <pre><code class="c" data-trim>
/*
** basic types
*/
#define LUA_TNONE       (-1)

#define LUA_TNIL        0
#define LUA_TBOOLEAN        1
#define LUA_TLIGHTUSERDATA  2
#define LUA_TNUMBER     3
#define LUA_TSTRING     4
#define LUA_TTABLE      5
#define LUA_TFUNCTION       6
#define LUA_TUSERDATA       7
#define LUA_TTHREAD     8

#define LUA_NUMTAGS     9
                        </code></pre>

                    </section>

                    <section>
                        <h4>How does the tag distinguish different types of lua value?</h4>

                        <p>lobject.h</p>

                        <pre><code class="c" data-trim>
/* raw type tag of a TValue */
#define rttype(o)   ((o)->tt_)

/* Macros to test type */
#define checktag(o,t)       (rttype(o) == (t))

#define ttistable(o)        checktag((o), LUA_TTABLE)

#define hvalue(o)   check_exp(ttistable(o), &val_(o).gc->h)
                        </code></pre>

                        <p>Simplified code here</p>
                    </section>

                    <section>
                        <h4>What is `Value`?</h4>

                        <pre><code class="c" data-trim>
union Value {
  GCObject *gc;    /* collectable objects */
  void *p;         /* light userdata */
  int b;           /* booleans */
  lua_CFunction f; /* light C functions */
  lua_Number n;    /* numbers */
};
                        </code></pre>

<!--
                        <p>Can `Value` distinguish different types of lua value?</p>
-->

                        <p>`Value` can be:</p>
                        <ul>
                            <li>nil? No! Tag of `TValue` is enough</li>
                        </ul>
                        <pre><code class="c" data-trim>
#define settt_(o,t) ((o)->tt_=(t))
#define setnilvalue(obj) settt_(obj, LUA_TNIL)
                        </code></pre>
                    </section>

                    <section>
                        <h4>What is `Value`?</h4>

                        <pre><code class="c" data-trim>
union Value {
  GCObject *gc;    /* collectable objects */
  void *p;         /* light userdata */
  int b;           /* booleans */
  lua_CFunction f; /* light C functions */
  lua_Number n;    /* numbers */
};
                        </code></pre>

                        <p>`Value` can be:</p>
                        <ul>
                            <li>boolean? Yes! `Value` = `b`</li>
                            <li>number? Yes! `Value` = `n`
                            <pre><code class="c" data-trim>
#define val_(o)		((o)->value_)
#define num_(o)		(val_(o).n)
#define setnvalue(obj,x) \
  { TValue *io=(obj); num_(io)=(x); settt_(io, LUA_TNUMBER); }
                            </code></pre>
                            </li>
                            <li>light userdata? Yes! `Value` = `p`</li>
                            <li>light C functions? Yes! `Value` = `f`</li>
                        </ul>
                    </section>

                    <section>
                        <h4>What is `Value`?</h4>

                        <pre><code class="c" data-trim>
union Value {
  GCObject *gc;    /* collectable objects */
  void *p;         /* light userdata */
  int b;           /* booleans */
  lua_CFunction f; /* light C functions */
  lua_Number n;    /* numbers */
};
                        </code></pre>

                        <p>`Value` can be:</p>
                        <ul>
                            <li>string, table, other function, heavy userdata, thread? `Value` = `gc`</li>
                        </ul>
                        <pre><code class="c" data-trim>
#define sethvalue(L,obj,x) \
  { TValue *io=(obj); \
    val_(io).gc=cast(GCObject *, (x)); settt_(io, LUA_TTABLE); }
                        </code></pre>
                    </section>

                    <section>
                        <h4>What is `GCObject` then?</h4>

                        <p>lstate.h</p>

                        <pre><code class="c" data-trim>
/*
** Union of all collectable objects
*/
typedef union GCObject GCObject;

union GCObject {
  GCheader gch;  /* common header */
  union TString ts;
  union Udata u;
  union Closure cl;
  struct Table h;
  struct Proto p;
  struct UpVal uv;
  struct lua_State th;  /* thread */
};
                        </code></pre>

                        <p>lstate.c - global state. Includes functions for opening and closing Lua states (lua_newstate/lua_close) and threads (luaE_newthread / luaE_freethread).</p>
                    </section>

                    <section>
                        <h4>What is `TValue`?</h4>
                        <img align="middle" height="600px;" data-src="img/TValue.png">
                    </section>

                    <section>
                        <h4>What is `TKey`?</h4>

                        <pre><code class="c" data-trim>
typedef union TKey {
  struct {
    Value value_;
    int tt_;
    struct Node *next;  /* for chaining */
  } nk;
  TValue tvk;
} TKey;
                        </code></pre>
                    </section>


                    <section>
                        <p>Macros related to `TKey`:</p>
                        <pre><code class="c" data-trim>
#define gkey(n)     (&(n)->i_key.tvk)
#define gnext(n)    ((n)->i_key.nk.next)
                        </code></pre>
                    </section>

                    <section>
                        <h4>Combine `TValue` and `TKey` into `Node`</h4>
                        <img align="middle" data-src="img/Node.png">
                    </section>

                    <section>
                        <h3>What happens when creating a `Table`?</h3>
                    </section>

                    <section>
                        <h4>General procedure of lua program:</h4>
                        <img align="middle" data-src="img/lua-procedure-simple.png">
                        <img align="middle" data-src="img/lua-procedure.png">

                        <p>Here we care about the execution phrase, and we will start our analysis from function `luaV_execute`.</p>
                    </section>

                    <section>
                        <h4>Start from the naive example</h4>
                        <pre><code class="lua" data-trim>
local t = {}
                        </code></pre>

                        <pre><code class="assembly" data-trim>
0+ params, 2 slots, 1 upvalue, 1 local, 0 constants, 0 functions
        1       [1]     NEWTABLE        0 0 0
        2       [1]     RETURN          0 1
                        </code></pre>

                        <p>Instructions related to table creation:</p>

                        <pre><code class="assembly" data-trim>
        1       [1]     NEWTABLE        0 0 0
                        </code></pre>
                    </section>

                    <section>
                        <h4>NEWTABLE instruction</h4>

                        <blockquote>
                            NEWTABLE A B C R(A) := {} (size = B,C)
                        </blockquote>

                        <ul>
                            <li>Creates a new empty table at register R(A).</li>
                            <li>B and C are the encoded size information for the array part and the hash part of the table, respectively. Appropriate values for B and C are set in order to avoid rehashing when initially populating the table with array values or hash key-value pairs. If an empty table is created, both sizes are zero.</li>
                        </ul>

                    </section>

                    <section>
                        <h4>Execute NEWTABLE in lua VM</h4>
                        <pre><code class="c" data-trim>
void luaV_execute (lua_State *L) {
  CallInfo *ci = L->ci;
  LClosure *cl;
  TValue *k;
  StkId base;
 newframe:  /* reentry point when frame changes (call/return) */
  lua_assert(ci == L->ci);
  cl = clLvalue(ci->func);
  k = cl->p->k;
  base = ci->u.l.base;
  /* main loop of interpreter */
  for (;;) {
    Instruction i = *(ci->u.l.savedpc++);
    StkId ra;
    if ((L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT)) &&
        (--L->hookcount == 0 || L->hookmask & LUA_MASKLINE)) {
      Protect(traceexec(L));
    }
    /* WARNING: several calls may realloc the stack and invalidate `ra' */
    ra = RA(i);
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    vmdispatch (GET_OPCODE(i)) {
      vmcase(OP_NEWTABLE,
        int b = GETARG_B(i);
        int c = GETARG_C(i);
        Table *t = luaH_new(L);
        sethvalue(L, ra, t);
        if (b != 0 || c != 0)
          luaH_resize(L, t, luaO_fb2int(b), luaO_fb2int(c));
        checkGC(L, ra + 1);
      )
    }
  }
}
                        </code></pre>
                    </section>

                    <section>
                        <h4>Execute NEWTABLE in lua VM</h4>
                        <p>A bit comfused? We only need to trace this part of code for the naive example:</p>

                        <pre><code class="c" data-trim>
      vmcase(OP_NEWTABLE,
        // Get the operator B from the instruction
        int b = GETARG_B(i);
        // Get the operator C from the instruction
        int c = GETARG_C(i);
        Table *t = luaH_new(L);
        // Remember this macro? ;)
        sethvalue(L, ra, t);
      )
                        </code></pre>

                        <p>Now we only need to look at `luaH_new`. :)</p>
                    </section>

                    <section>
                        <h4>Execute NEWTABLE in lua VM</h4>

                        <pre><code class="c" data-trim>
Table *luaH_new (lua_State *L) {
  Table *t = &luaC_newobj(L, LUA_TTABLE, sizeof(Table), NULL, 0)->h;
  t->array = NULL;
  t->sizearray = 0;
  setnodevector(L, t, 0);
  return t;
}

static void setnodevector (lua_State *L, Table *t, int size) {
  int lsize;
  if (size == 0) {  /* no elements to hash part? */
    t->node = cast(Node *, dummynode);  /* use common `dummynode' */
    lsize = 0;
  }
  else {
    int i;
    lsize = luaO_ceillog2(size);
    if (lsize > MAXBITS)
      luaG_runerror(L, "table overflow");
    size = twoto(lsize);
    t->node = luaM_newvector(L, size, Node);
    for (i=0; i<size; i++) {
      Node *n = gnode(t, i);
      gnext(n) = NULL;
      setnilvalue(gkey(n));
      setnilvalue(gval(n));
    }
  }
  t->lsizenode = cast_byte(lsize);
  t->lastfree = gnode(t, size);  /* all positions are free */
}
                        </code></pre>

                        <p>
                        </p>
                    </section>

                    <section>
                        <h4>It's simpler in our case...</h4>

                        <pre><code class="c" data-trim>
Table *luaH_new (lua_State *L) {
  Table *t = &luaC_newobj(L, LUA_TTABLE, sizeof(Table), NULL, 0)->h;
  t->array = NULL;
  t->sizearray = 0;
  t->node = cast(Node *, dummynode);  /* use common `dummynode' */
  t->lsizenode = 0;
  t->lastfree = gnode(t, size);  /* all positions are free */
  return t;
}
                        </code></pre>

                    </section>

                    <section>
                        <h4>What's dummynode?</h4>

                        <pre><code class="c" data-trim>
/* macro defining a nil value */
#define NILCONSTANT {NULL}, LUA_TNIL

#define dummynode       (&dummynode_)

#define isdummy(n)      ((n) == dummynode)

static const Node dummynode_ = {
  {NILCONSTANT},  /* value */
  {{NILCONSTANT, NULL}}  /* key */
};
                        </code></pre>

                        <p>All empty table in lua points to the same memory area. CLEVER LUA!</p>
                    </section>

                    <section>
                        <h3>What happens when creating a `Table`?</h3>
                        <h4>What about creating a non-empty table?</h4>
                        <p>We will come back later. ;)</p>
                    </section>

                    <section>
                        <h3>What happens when accessing a `Table`?</h3>
                    </section>

                    <section>
                        <h3>Another naive example:</h3>
                        <pre><code class="c" data-trim>
                        </code></pre>

                        <p>
                        </p>
                    </section>

                    <section>
                        <h2></h2>
                        <p>
                        </p>
                    </section>

                    <section>
                        <h2></h2>
                        <p>
                        </p>
                    </section>

                    <section>
                        <h2></h2>
                        <p>
                        </p>
                    </section>

                    <section>
                        <h2></h2>
                        <p>
                        </p>
                    </section>

                    <section>
                        <h2></h2>
                        <p>
                        </p>
                    </section>

                    <section>
                        <h2></h2>
                        <p>
                        </p>
                    </section>

                    <section>
                        <h2></h2>
                        <p>
                        </p>
                    </section>

                </section>
			</div>
		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>
			// More info https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				history: true,

				// More info https://github.com/hakimel/reveal.js#dependencies
				dependencies: [
					{ src: 'plugin/markdown/marked.js' },
					{ src: 'plugin/markdown/markdown.js' },
					{ src: 'plugin/notes/notes.js', async: true },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
				]
			});
		</script>
	</body>
</html>
