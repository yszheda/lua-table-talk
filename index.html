<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>reveal.js</title>

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/sky.css">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<section>
                    <h1>"table" in Lua</h1>
                </section>

                <section>
                    <h2>Outline</h2>
                    <ul>
                        <li>Basic of Lua "table"</li>
                        <li>Adapt Lua "table" for multiple data structure</li>
                        <li>Dive into Lua "table" source code</li>
                    </ul>
                </section>

				<section>
                    <section>
                        <h2>Overview of Lua</h2>
                    </section>

                    <section>
                        <h2>Overview of Lua</h2>
                        <ul>
                            <li>Lua is a powerful, efficient, lightweight, embeddable <b>scripting language</b>.</li>
                            <li><b>multi-paradigm</b>: Lua supports procedural programming, object-oriented programming, functional programming, etc.</li>
                            <li><b>dynamically-type</b>: types are attached to values rather than to variables.</li>
                            <li>Lua has <b>automatic memory management</b> with incremental <b>garbage collection</b>.</li>
                        </ul>

                        <aside class="notes">
                        </aside>
                    </section>

                    <section>
                        <h2>Overview of Lua</h2>
                        <ul>
                            <li>basic types (first-class):
                            <ol>
                                <li><code>nil</code> (like "None" in Python, including undefined variables)</li>
                                <li>boolean: <code>true</code>, <code>false</code></li>
                                <li>number: double-precision floating-point numbers (like "double" in C)</li>
                                <li>string: immutable (once internalized, cannot be changed)</li>
                                <li>table: associative arrays</li>
                                <li>function: Lua functions, C functions</li>
                                <li>heavy userdata</li>
                                <li>light userdata</li>
                                <li>thread: coroutines</li>
                            </ol>
                            </li>
                        </ul>
                    </section>
                </section>

				<section>
                    <h2>Overview of table in Lua</h2>
                    <ul>
                        <li>Tables are the main — in fact, the only — data-structuring mechanism in Lua.</li>
                        <li>Tables in Lua are associative arrays, that is, they can be indexed by any value (except nil) and can hold values of any type.</li>
                        <li>Tables are dynamic in the sense that they may grow when data is added to them (by assigning a value to a hitherto non-existent field) and shrink when data is removed from them (by assigning nil to a field).</li>
                    </ul>

					<aside class="notes">
					</aside>
                </section>

                <section>
                    <section>
                        <h2>Basic</h2>
                    </section>

                    <section>
                        <h3>Table Creation</h3>
                        <pre><code class="lua" data-trim>
-- This is a comment.

-- Empty table
local t1 = {}

-- Table as an array
local t2 = { 1, 2, "str", t1 }

-- Table as a hashtable
local t3 = {
    ["k1"] = "v1",
    k2 = "v2",
}

-- Table as mixed data structure of array and hashtable
local t4 = {
    "e1",           -- stored in the array part
    ["k1"] = "v1",  -- stored in the hash part
    k2 = "v2",      -- stored in the hash part
}
                        </code></pre>
                    </section>

                    <section>
                        <h3>Table As An Array</h3>
                        <p>Array Operations:</p>
                        <br>
                        <ul>
                            <li>Set the element of position "n"</li>
                            <li>Get the element of position "n"</li>
                            <li>Get the number of elements</li>
                            <li>Iterate over all elements</li>
                            <li>Delete the element of position "n"</li>
                        </ul>
                    </section>

                    <section>
                        <h4>Table As An Array: Setter</h4>
                        <p>Set the element of position "n"</p>

                        <blockquote>
                            NOTE: index in Lua starts from 1
                        </blockquote>

                        <pre><code class="lua" data-trim>
-- Way #1: specify the index
local t = {}
t[1] = "e1"
t[2] = "e2"
t[3] = "e3"
t[4] = "e4"
                        </code></pre>

                        <pre><code class="lua" data-trim>
-- Way #2: use table.insert (list, [pos,] value)
local t = {}
table.insert(t, 1, "e1")
table.insert(t, 2, "e2")
-- table.insert(t, x) inserts x at the end of list t
table.insert(t, "e3")
table.insert(t, "e4")
                        </code></pre>

                        <p>See the <a href="https://www.lua.org/manual/5.2/manual.html#pdf-table.insert">manual of <code>table.insert</code></a></p>
                    </section>

                    <section>
                        <h4>Table As An Array: Getter</h4>
                        <p>Get the element of position "n"</p>

                        <pre><code class="lua" data-trim>
local t = {"e1", "e2", "e3", "e4"}
-- Get the fourth element
print(t[4])

--[[
This is a multi-line comment.

Output:
e4
]]
                        </code></pre>
                    </section>

                    <section>
                        <h4>Table As An Array: Get element number</h4>
                        <p>Get the number of elements</p>

                        <pre><code class="lua" data-trim>
local t = {"e1", "e2", "e3", "e4"}

-- Way #1: the length operator "#"
print(#t)

--[[
Output:
4
]]

-- Way #2
--[[
table.unpack(t) returns "e1", "e2", "e3", "e4"
so it becomes:
print(select('#', "e1", "e2", "e3", "e4"))
]]
print(select('#', table.unpack(t)))
                        </code></pre>

                        <p style="font-size: 24px;">Refer to:
                        <ul style="font-size: 24px;">
                            <li><a href="https://www.lua.org/manual/5.2/manual.html#3.4.6">manual of the length operator "#"</a></li>
                            <li><a href="https://www.lua.org/manual/5.2/manual.html#pdf-select">manual of <code>select</code></a></li>
                            <li><a href="https://www.lua.org/manual/5.2/manual.html#pdf-table.unpack">manual of <code>table.unpack</code></a></li>
                        </ul>
                        </p>
                    </section>

                    <section>
                        <h4>Table As An Array: Iteration</h4>
                        <p>Iterate over all elements</p>

                        <pre><code class="lua" data-trim>
local t = {"e1", "e2", "e3", "e4"}

-- Forward iteration
for i = 1, 4 do
    print(t[i])
end

--[[
Output:
e1
e2
e3
e4
]]

-- More general way:
for i = 1, #t do
    print(t[i])
end

--[[
Output:
e1
e2
e3
e4
]]

-- Backward iteration: 
-- for i = start, end, step do
-- end
for i = #t, 1, -1 do
    print(t[i])
end


--[[
Output:
e4
e3
e2
e1
]]
                        </code></pre>

                        <p class="fragment">There's another way of using an <b>iterator</b>. We will talk about that later.</p>
                    </section>

                    <section>
                        <h4>Table As An Array: Delete</h4>
                        <p>Delete the element of position "n"</p>

                        <pre><code class="lua" data-trim>
-- Way #1: set the specified element as nil
local t = {"e1", "e2", "e3", "e4"}

-- Delete the third element
t[3] = nil

--[[
NOTE:
1. Lua table will not pack the elements backward to fill the empty slot
2. the number of elements will not change
]]
print("The number of elements:", #t)
for i = 1, #t do
    print(t[i])
end

--[[
Output:
The number of elements: 4
e1
e2
nil
e4
]]
                        </code></pre>
                    </section>

                    <section>
                        <h4>Table As An Array: Delete</h4>
                        <p>Delete the element of position "n"</p>

                        <pre><code class="lua" data-trim>
-- Way #2: use table.remove (list [, pos])
local t = {"e1", "e2", "e3", "e4"}

table.remove(t, 3)
print("The number of elements:", #t)
for i = 1, #t do
    print(t[i])
end

--[[
Output:
The number of elements: 3
e1
e2
e4
]]

-- table.remove(t) removes the last element of list t.
table.remove(t)
print("The number of elements:", #t)
for i = 1, #t do
    print(t[i])
end

--[[
Output:
The number of elements: 2
e1
e2
]]
                        </code></pre>

                        <p>See the <a href="https://www.lua.org/manual/5.2/manual.html#pdf-table.remove">manual of <code>table.remove</code></a></p>
                    </section>

                    <section>
                        <h4>Table As An Array: Delete</h4>
                        <p>Common misuse of <code>table.remove</code> in a loop</p>

                        <pre><code class="lua" data-trim>
local t = {1, 2, 3, 4}

for i = 1, #t do
    if t[i] < 4 then
        table.remove(t, i)
    end
end

--[[
Opps...
lua: xxx.lua:4: attempt to compare nil with number
stack traceback:
        xxx.lua:4: in main chunk
        [C]: in ?

]]
                        </code></pre>

                        <p class="fragment">Why?</p>
                    </section>

                    <section>
                        <h4>Table As An Array: Delete</h4>
                        <p>Trace the source code using <code>print</code></p>

                        <pre><code class="lua" data-trim>
local t = {1, 2, 3, 4}

for i = 1, #t do
    print(i, t[i])
    if t[i] < 4 then
        table.remove(t, i)
    end
end

--[[
1       1
2       3
3       nil
lua: xxx.lua:5: attempt to compare nil with number
stack traceback:
        xxx.lua:5: in main chunk
        [C]: in ?
]]
                        </code></pre>
                    </section>

                    <section>
                        <h4>Table As An Array: Delete</h4>
                        <p>Straightforward solution: use backward iteration.</p>

                        <pre><code class="lua" data-trim>
local t = {1, 2, 3, 4}

for i = #t, 1, -1 do
    if t[i] < 4 then
        table.remove(t, i)
    end
end

for i = 1, #t do
    print(t[i])
end

--[[
Output:
4
]]
                        </code></pre>

                        <p class="fragment">We will see another misuse case of <code>table.remove</code> when we discuss iterator ;)</p>
                    </section>

                    <section>
                        <h3>Table As A Hashtable</h3>
                        <p>Hashtable Operations:</p>
                        <br>
                        <ul>
                            <li>Set the value of key "k"</li>
                            <li>Get the value of key "k"</li>
                            <li>Delete the value of key "k"</li>
                            <li>Iterate over all key-value pairs</li>
                            <li>Get the number of key-value pairs</li>
                        </ul>
                    </section>

                    <section>
                        <h4>Table As A Hashtable: Setter</h4>

                        <pre><code class="lua" data-trim>
local t = {}

-- Way #1
t["key"] = "value"

-- Way #2: syntactic sugar
t.key = "value"

-- Compare with the following code:
local key = "key"
t[key] = "value"
                        </code></pre>
                    </section>

                    <section>
                        <h4>Table As A Hashtable: Getter</h4>

                        <pre><code class="lua" data-trim>
local t = {
    "key" = "value",
}

print("t[\"key\"] = ", t["key"])
print("t.key = ", t.key)

local k = "key"
print("t[k] = ", t[k])
-- t.k is equivalent to t["k"]
print("t.k = ", t.k)

--[[
Output:
t["key"] =      value
t.key =         value
t[k] =  value
t.k =   nil
]]
                        </code></pre>
                    </section>

                    <section>
                        <h4>Table As A Hashtable: Delete</h4>

                        <pre><code class="lua" data-trim>
local t = {
    "key" = "value",
}

t.key = nil
                        </code></pre>
                    </section>

                    <section>
                        <h4>Table As A Hashtable: Iteration</h4>
                        <p>?</p>
                    </section>

                    <section>
                        <h4>Table As A Hashtable: Iteration</h4>
                        <p>Meet `<code>next (table [, index])</code>`</p>

                        <blockquote>
                            <p style="font-size: 28px;">Allows a program to traverse all fields of a table. Its first argument is a table and its second argument is an index in this table. next returns the next index of the table and its associated value. When called with nil as its second argument, next returns an initial index and its associated value. When called with the last index, or with nil in an empty table, next returns nil. If the second argument is absent, then it is interpreted as nil. In particular, you can use next(t) to check whether a table is empty.</p>
                        </blockquote>
                    </section>

                    <section>
                        <h4>Table As A Hashtable: Iteration</h4>
                        <pre><code class="lua" data-trim>
local t = {
    k1 = "v1",
    k2 = "v2",
    k3 = "v3",
}

local k, v
-- Note: equivalent to:
-- local k = nil
-- local v = nil
for i = 1, 3 do
    k, v = next(t, k)
    print(k, v)
end

-- NOTE: The order in which the indices are enumerated is not specified, even for numeric indices.
--[[
Output:
k1      v1
k3      v3
k2      v2
]]
                        </code></pre>

                        <p>See the <a href="https://www.lua.org/manual/5.2/manual.html#pdf-next">manual of <code>next</code></a></p>
                    </section>

                    <section>
                        <h4>Table As A Hashtable: Iteration</h4>
                        <p>What if we don't know there's three key-value pairs in the table `<code>t</code>`?</p>

                        <pre class="fragment"><code class="lua" data-trim>
local t = {
    k1 = "v1",
    k2 = "v2",
    k3 = "v3",
}

local k, v = next(t, k)
while k do
-- Note: equivalent to:
-- while k ~= nil do
    print(k, v)
    k, v = next(t, k)
end

--[[
Output:
k2      v2
k1      v1
k3      v3
]]
                        </code></pre>
                    </section>

                    <section>
                        <h4>Iterator</h4>
                        <p>Advanced skill: meet the "generic <code>for</code>" in Lua.</p>

                        <pre><code class="lua" data-trim>
for {var-list} in {exp-list} do
    {body}
end
                        </code></pre>

                        <p class="fragment">Now we can write an iterator and use it in the generic <code>for</code> loop!</p>
                    </section>

                    <section>
                        <h4>Iterator</h4>
                        <p>Hand-written iterator (V1):</p>

                        <pre><code class="lua" data-trim>
local t = {
    k1 = "v1",
    k2 = "v2",
    k3 = "v3",
}

local function iter(t)
    local last_k
    return function()
        local v
        last_k, v = next(t, last_k)
        return last_k, v
    end
end

-- Use the iterator in the generic for loop
for k, v in iter(t) do
    print(k, v)
end

--[[
Output:
k3      v3
k2      v2
k1      v1
]]

-- Use the iterator to rewrite the previous while loop
local producer = iter(t)
local k, v = producer()
while k do
    print(k, v)
    k, v = producer()
end

--[[
Output:
k3      v3
k2      v2
k1      v1
]]
                        </code></pre>

                        <p class="fragment">It would be difficult to understand if you don't know anything about closure or lambda! :(</p>
                    </section>

                    <section>
                        <h4>Iterator</h4>
                        <p>Hand-written iterator (V2): 
                        we can pass a function and its parameters in {exp-list} of "generic <code>for</code>".</p>

                        <pre><code class="lua" data-trim>
local t = {
    k1 = "v1",
    k2 = "v2",
    k3 = "v3",
}

for k, v in next, t do
    print(k, v)
end

--[[
Output:
k3      v3
k2      v2
k1      v1
]]
                        </code></pre>

                        <ul class="fragment">
                            <li>Simpler code :)</li>
                            <li>It would still be difficult to understand if you don't know functions in Lua are first-class variables! :(</li>
                        </ul>
                    </section>

                    <section>
                        <h4>Iterator</h4>
                        <p>There's a built-in iterator: `<code>pairs</code>`! XD</p>

                        <pre class="fragment"><code class="lua" data-trim>
local t = {
    k1 = "v1",
    k2 = "v2",
    k3 = "v3",
}

for k, v in pairs(t) do
    print(k, v)
end

--[[
Output:
k3      v3
k1      v1
k2      v2
]]
                        </code></pre>

                        <p class="fragment">See the <a href="https://www.lua.org/manual/5.2/manual.html#pdf-pairs">manual of <code>pairs</code></a></p>
                    </section>

                    <section>
                        <h4>Iterator</h4>
                        <p>There's another built-in iterator for array: `<code>ipairs</code>`! XD</p>

                        <pre class="fragment"><code class="lua" data-trim>
local t = {"e1", "e2", "e3", "e4"}

-- Only forward iteration
for i, v in ipairs(t) do
    print(i, v)
end

--[[
Output:
1       e1
2       e2
3       e3
4       e4
]]
                        </code></pre>

                        <p class="fragment">See the <a href="https://www.lua.org/manual/5.2/manual.html#pdf-ipairs">manual of <code>ipairs</code></a></p>
                    </section>

                    <section>
                        <p>Now we can talk about another common misuse of <code>table.remove</code> in loop.</p>

                        <pre><code class="lua" data-trim>
local t = {1, 2, 3, 4}

for i, v in ipairs(t) do
    print("Access the element: ", v)
    if v < 4 then
        table.remove(t, i)
    end
end

print("Result:")
for i, v in ipairs(t) do
    print(i, v)
end

--[[
Output:
Access the element:     1
Access the element:     3
Result:
1       2
2       4
]]
                        </code></pre>
                    </section>

                    <section>
                        <h4>Table As A Hashtable: Get the Number of key-value Pairs</h4>

                        <pre><code class="lua" data-trim>
local t = {
    k1 = "v1",
    k2 = "v2",
    k3 = "v3",
}

-- Try the length operator "#":
print(#t)

--[[
Output:
0
]]
                        </code></pre>

                        <p class="fragment">Opps...The length operator <code>"#"</code> only deals with the array part of table. :(</p>
                    </section>

                    <section>
                        <h4>Table As A Hashtable: Get the Number of key-value Pairs</h4>
                        <p class="fragment">Since we know how to iterator over the table, we know how to count all the key-value pairs. :)</p>

                        <pre class="fragment"><code class="lua" data-trim>
local t = {
    k1 = "v1",
    k2 = "v2",
    k3 = "v3",
}

local cnt = 0
for i, v in pairs(t) do
    cnt = cnt + 1
end

print(cnt)

--[[
Output:
3
]]
                        </code></pre>

                        <p class="fragment">Complexity: O(N)</p>
                    </section>

                </section>

                <section>
                    <section>
                        <h2>Data Structure</h2>
                    </section>

                    <section>
                        <h3>Matrices / Multi-Dimensional Arrays</h3>

                        <p>Like C array:</p>

                        <pre><code class="lua" data-trim>
-- Create a matrix of zeros with dimensions N by M

-- Way #1
mt = {}             -- create the matrix
for i = 1, N do
    mt[i] = {}      -- create a new row
    for j = 1, M do
        mt[i][j] = 0
    end
end

-- Way #2
mt = {}             -- create the matrix
for i = 1, N do
    for j = 1, M do
        mt[i*M + j] = 0
    end
end
                        </code></pre>
                    </section>

                    <section>
                        <h3>Linked Lists</h3>

                        <pre><code class="lua" data-trim>
-- local node = {next = node, value = v}
-- local list = first_node

function traverse(list)
    local node = list
    while node do
        print(node.value)
        node = node.next
    end
end

-- We counting the nodes from 1
function insert_kth_node(list, k, node)
    assert(k > 0, "invalid k")

    -- Insert from front
    if k == 1 then
        node.next = list
        return
    end

    local previous_node = list
    for i = 1, k-1 do
        assert(previous_node.next, "invalid k")
        previous_node = previous_node.next
    end

    node.next = previous_node.next
    previous_node.next = node
end

function delete_kth_node(list, k)
    assert(k > 0, "invalid k")

    local previous_node = list
    for i = 1, k-1 do
        assert(previous_node.next, "invalid k")
        previous_node = previous_node.next
    end

    local node = previous_node.next
    if node then
        previous_node.next = node.next
        node = nil      -- to allow garbage collection
    end
end
                        </code></pre>
                    </section>

                    <section>
                        <h3>Stacks</h3>

                        <pre><code class="lua" data-trim>
-- Use Stack as a namespace
local Stack = {}

function Stack.push(stack, element)
    table.insert(stack, element)
end

function Stack.pop(stack)
    table.remove(stack)
end

function Stack.top(stack)
    return stack[#stack]
end
                        </code></pre>
                    </section>

                    <section>
                        <h3>Queues and Double Queues</h3>

                        <pre><code class="lua" data-trim>
local Queue = {}

function Queue.new()
    return {first = 0, last = -1}
end

function Queue.pushleft(queue, value)
    local first = queue.first - 1
    queue.first = first
    queue[first] = value
end

function Queue.pushright(queue, value)
    local last = queue.last + 1
    queue.last = last
    queue[last] = value
end

function Queue.popleft(queue)
    local first = queue.first
    assert(first <= queue.last, "queue is empty")
    local value = queue[first]
    queue[first] = nil        -- to allow garbage collection
    queue.first = first + 1
    return value
end

function Queue.popright(list)
    local last = queue.last
    assert(queue.first <= last, "queue is empty")
    local value = queue[last]
    queue[last] = nil         -- to allow garbage collection
    queue.last = last - 1
    return value
end
                        </code></pre>
                    </section>

                    <section>
                        <h3>Sets</h3>

                        <pre><code class="lua" data-trim>
local Set = {}

function Set.new()
    return {}
end

function Set.add(set, element)
    set[element] = true
end

function Set.has(set, element)
    return set[element]
end

-- Union of two sets
function Set.union(set1, set2)
    local union = {}
    for _, set in ipairs({set1, set2}) do
        for k, _ in pairs(set) do
            union[k] = true
        end
    end
    return union
end

--[[
For advanced Lua user, you can write a more general function for set union.
e.g.

function Set.union(...)
    local union = {}
    for _, set in ipairs({...}) do
        for k, _ in pairs(set) do
            union[k] = true
        end
    end
    return union
end
]]

-- Intersection of two sets
function Set.intersect(set1, set2)
    local intersect = {}
    for k, _ in pairs(set1) do
        intersect[k] = set2[k]
    end
    return intersect
end

--[[
For advanced Lua user, you can write a more general function for set intersection.
e.g.

-- This is a naive version of counting elements:

function Set.intersect(...)
    local intersect = {}
    local set_list = {...}
    for _, set in ipairs(set_list) do
        for k, _ in pairs() do
            if intersect[k] then
                intersect[k] = intersect[k] + 1
            else
                intersect[k] = 1
            end
        end
    end

    local num_of_set = #set_list
    for k, num in pairs(intersect) do
        if num < num_of_set then
            intersect[k] = nil
        else
            intersect[k] = true
        end
    end

    return intersect
end

-- This is a better version:

function Set.intersect(...)
    local intersect = {}
    local set_list = {...}
    local first_set = set_list[1]
    local num_of_set = #set_list
    for k, _ in pairs(first_set) do
        intersect[k] = true
        for i = 2, num_of_set do
            local set = set_list[i]
            -- equivalent to: 
            -- set[k] == nil or set[k] == false
            if not set[k] then
                intersect[k] = nil
                break
            end
        end
    end
    return intersect
end
]]
                        </code></pre>
                    </section>

                </section>

                <section>
                    <section>
                        <h2>Dive into Lua Source Code</h2>
                        <p>The version of Lua source code is 5.2</p>
                        <p>I omit and modify some code for simplicity. XD</p>
                    </section>

                    <section>
                        <h3>How do Lua store table?</h3>
                    </section>

                    <section>
                        <h4>How do Lua store table?</h4>

                        <p>Definition in lobject.h:</p>

                        <pre><code class="c" data-trim>
typedef struct Table {
  lu_byte lsizenode;  /* log2 of size of `node' array */
  TValue *array;  /* array part */
  Node *node;
  Node *lastfree;  /* any free position is before this position */
  int sizearray;  /* size of `array' array */
} Table;
                        </code></pre>
                    </section>

                    <section>
                        <h4>What does `<code>Table</code>` contain?</h4>
                        <ul>
                            <li>A `<code>Table</code>` instance has at lease three continued areas in memory:
                            <ul>
                                <img align="middle" data-src="img/Table-simple.png">
                                <li>The `<code>Table</code>` instance itself.</li>
                                <li>`<code>array</code>`: array part of `<code>Table</code>`</li>
                                <li>`<code>node</code>`: hash part of `<code>Table</code>`</li>
                            </ul>
                            </li>
                        </ul>
                    </section>

                    <section>
                        <h4>What does `<code>Table</code>` contain?</h4>
                        <ul>
                            <li>Fields of recording the size:
                            <ul>
                                <li>size of array part: `<code>sizearray</code>`</li>
                                <li>size of hash part: 2^`<code>lsizenode</code>`</li>
                                <pre><code class="c" data-trim>
#define twoto(x)    (1<<(x))
#define sizenode(t) (twoto((t)->lsizenode))
                                </code></pre>
                            </ul>
                            </li>
                        </ul>
                    </section>

                    <section>
                        <p>Macros related to `<code>Table</code>`:</p>
                        <pre><code class="c" data-trim>
#define gnode(t,i)  (&(t)->node[i])
                        </code></pre>

                        <p>We will meet this macro later. ;)</p>
                    </section>

                    <section>
                        <h4>What is `<code>Node</code>`?</h4>

                        <pre><code class="c" data-trim>
typedef struct Node {
  TValue i_val;
  TKey i_key;
} Node;
                        </code></pre>

                        <p>`<code>Node</code>` is the structure for key-value pair</p>
                    </section>

                    <section>
                        <p>Macros related to `<code>Node</code>`:</p>
                        <pre><code class="c" data-trim>
#define gval(n)     (&(n)->i_val)
                        </code></pre>
                    </section>

                    <section>
                        <h4>What is `<code>TValue</code>` then?</h4>

                        <pre><code class="c" data-trim>
typedef struct lua_TValue TValue;

/*
** Tagged Values. This is the basic representation of values in Lua,
** an actual value plus a tag with its type.
*/

struct lua_TValue {
  Value value_;
  int tt_;
};
                        </code></pre>

                        <p>`<code>TValue</code>` = Tagged Value</p>
                        <ul>
                            <li>`<code>TValue</code>` contains the value and a type tag</li>
                            <li>Lua represents values as tagged unions, that is, as pairs (t, v), where t is an integer tag identifying the type of the value v, which is a union of C types implementing Lua types.</li>
                            <li>omitted source code: NaN Trick</li>
                        </ul>
                    </section>

                    <section>
                        <p>Macros related to `<code>TValue</code>`:</p>

                        <pre><code class="c" data-trim>
#define val_(o)     ((o)->value_)

/* raw type tag of a TValue */
#define rttype(o)   ((o)->tt_)


#define setobj(L,obj1,obj2) \
    { const TValue *io2=(obj2); TValue *io1=(obj1); \
      io1->value_ = io2->value_; io1->tt_ = io2->tt_; }
                        </code></pre>

                        <p>We will meet these macros later. ;)</p>
                    </section>

                    <section>
                        <h4>How does the tag distinguish different types of Lua value?</h4>

                        <p>lua.h</p>
                        <pre><code class="c" data-trim>
/*
** basic types
*/
#define LUA_TNONE       (-1)

#define LUA_TNIL        0
#define LUA_TBOOLEAN        1
#define LUA_TLIGHTUSERDATA  2
#define LUA_TNUMBER     3
#define LUA_TSTRING     4
#define LUA_TTABLE      5
#define LUA_TFUNCTION       6
#define LUA_TUSERDATA       7
#define LUA_TTHREAD     8

#define LUA_NUMTAGS     9
                        </code></pre>

                    </section>

                    <section>
                        <h4>How does the tag distinguish different types of Lua value?</h4>

                        <pre><code class="c" data-trim>
/* raw type tag of a TValue */
#define rttype(o)   ((o)->tt_)

/* Macros to test type */
#define checktag(o,t)       (rttype(o) == (t))

#define ttistable(o)        checktag((o), LUA_TTABLE)

#define hvalue(o)   check_exp(ttistable(o), &val_(o).gc->h)
                        </code></pre>

                        <p>Again, we will meet these macros later. ;)</p>
                    </section>

                    <section>
                        <h4>What is `<code>Value</code>`?</h4>

                        <pre><code class="c" data-trim>
union Value {
  GCObject *gc;    /* collectable objects */
  void *p;         /* light userdata */
  int b;           /* booleans */
  lua_CFunction f; /* light C functions */
  lua_Number n;    /* numbers */
};
                        </code></pre>

                        <p>`<code>Value</code>` can be:</p>
                        <ul class="fragment">
                            <li>`<code>nil</code>`? No! Tag of `<code>TValue</code>` is enough.</li>
                            <pre><code class="c" data-trim>
#define settt_(o,t) ((o)->tt_=(t))
#define setnilvalue(obj) settt_(obj, LUA_TNIL)
#define ttisnil(o)      checktag((o), LUA_TNIL)
                            </code></pre>
                        </ul>
                    </section>

                    <section>
                        <h4>What is `<code>Value</code>`?</h4>

                        <pre><code class="c" data-trim>
union Value {
  GCObject *gc;    /* collectable objects */
  void *p;         /* light userdata */
  int b;           /* booleans */
  lua_CFunction f; /* light C functions */
  lua_Number n;    /* numbers */
};
                        </code></pre>

                        <p>`<code>Value</code>` can be:</p>
                        <ul>
                            <li class="fragment">boolean? Yes! `Value` = `b`</li>
                            <li class="fragment">number? Yes! `Value` = `n`
                            <pre><code class="c" data-trim>
#define val_(o)		((o)->value_)
#define num_(o)		(val_(o).n)
#define nvalue(o)   check_exp(ttisnumber(o), num_(o))
#define setnvalue(obj,x) \
  { TValue *io=(obj); num_(io)=(x); settt_(io, LUA_TNUMBER); }
                            </code></pre>
                            </li>
                            <li class="fragment">light userdata? Yes! `Value` = `p`</li>
                            <li class="fragment">light C functions? Yes! `Value` = `f`</li>
                        </ul>
                    </section>

                    <section>
                        <h4>What is `<code>Value</code>`?</h4>

                        <pre><code class="c" data-trim>
union Value {
  GCObject *gc;    /* collectable objects */
  void *p;         /* light userdata */
  int b;           /* booleans */
  lua_CFunction f; /* light C functions */
  lua_Number n;    /* numbers */
};
                        </code></pre>

                        <p>`<code>Value</code>` can be:</p>
                            <ul class="fragment">
                                <li>string, table, other function, heavy userdata, thread? `Value` = `gc`</li>
                                <pre><code class="c" data-trim>
#define sethvalue(L,obj,x) \
  { TValue *io=(obj); \
    val_(io).gc=cast(GCObject *, (x)); settt_(io, LUA_TTABLE); }
                                </code></pre>
                            </ul>
                        </section>

                    <section>
                        <h4>What is `<code>GCObject</code>` then?</h4>

                        <p>lstate.h</p>

                        <pre><code class="c" data-trim>
/*
** Union of all collectable objects
*/
typedef union GCObject GCObject;

union GCObject {
  GCheader gch;  /* common header */
  union TString ts;
  union Udata u;
  union Closure cl;
  struct Table h;
  struct Proto p;
  struct UpVal uv;
  struct lua_State th;  /* thread */
};
                        </code></pre>
                    </section>

                    <section>
                        <h4>Review: what is `<code>TValue</code>`?</h4>
                        <img align="middle" height="600px;" data-src="img/TValue.png">
                    </section>

                    <section>
                        <h4>What is `<code>TKey</code>`?</h4>

                        <pre><code class="c" data-trim>
typedef union TKey {
  struct {
    Value value_;
    int tt_;
    struct Node *next;  /* for chaining */
  } nk;
  TValue tvk;
} TKey;
                        </code></pre>
                    </section>


                    <section>
                        <p>Macros related to `<code>TKey</code>`:</p>
                        <pre><code class="c" data-trim>
#define gkey(n)     (&(n)->i_key.tvk)
#define gnext(n)    ((n)->i_key.nk.next)
                        </code></pre>
                    </section>

                    <section>
                        <h4>Review: what is `<code>Node</code>`?</h4>
                        <p>Combine `<code>TValue</code>` and `<code>TKey</code>` into `<code>Node</code>`.</p>
                        <img align="middle" data-src="img/Node.png">
                    </section>

                    <section>
                        <h3>What happens when creating a `<code>Table</code>`?</h3>
                    </section>

                    <section>
                        <h4>General procedure of Lua program:</h4>
                        <p>Lua programs are not interpreted directly from the textual Lua file, but are compiled into bytecode, which is then run on the Lua virtual machine.</p>
                        <img align="middle" data-src="img/lua-procedure-simple.png">
                    </section>

                    <section>
                        <h4>General procedure of Lua program:</h4>
                        <img align="middle" height="500px;" data-src="img/lua-procedure.png">

                        <p>Here we care about the execution phrase, and we will start our analysis from function `<code>luaV_execute</code>`.</p>
                    </section>

                    <section>
                        <h4>Brief introduction of Lua VM and its instructions</h4>
                        <ul>
                            <li>fixed size (32 bit unsigned integer)</li>
                            <li>register-based</li>
                            <li>instruction formats (`sBx' : signed Bx):</li>
                            <img align="middle" data-src="img/instruction.png">
                            <li>We will meet the following guys later:
                            <ul>
                                <li>R(A) : Register A</li>
                                <li>RK(B) : Register B or a constant index</li>
                            </ul>
                            </li>
                        </ul>
                    </section>

                    <section>
                        <h4>Start from the naive example</h4>
                        <pre><code class="lua" data-trim>
local t = {}
                        </code></pre>

                        <pre><code class="assembly" data-trim>
0+ params, 2 slots, 1 upvalue, 1 local, 0 constants, 0 functions
        1       [1]     NEWTABLE        0 0 0
        2       [1]     RETURN          0 1
                        </code></pre>

                        <p>Instructions related to table creation:</p>

                        <pre><code class="assembly" data-trim>
        1       [1]     NEWTABLE        0 0 0
                        </code></pre>
                    </section>

                    <section>
                        <h4>NEWTABLE instruction</h4>

                        <blockquote>
                            NEWTABLE A B C R(A) := {} (size = B,C)
                        </blockquote>

                        <ul>
                            <li>Creates a new empty table at register R(A).</li>
                            <li>B: encoded size information for the array part of the table.</li>
                            <li>C: encoded size information for the hash part of the table.</li>
                        </ul>

                    </section>

                    <section>
                        <h4>Execute NEWTABLE in Lua VM</h4>
                        <pre><code class="c" data-trim>
void luaV_execute (lua_State *L) {
  CallInfo *ci = L->ci;
  LClosure *cl;
  TValue *k;
  StkId base;
 newframe:  /* reentry point when frame changes (call/return) */
  lua_assert(ci == L->ci);
  cl = clLvalue(ci->func);
  k = cl->p->k;
  base = ci->u.l.base;
  /* main loop of interpreter */
  for (;;) {
    Instruction i = *(ci->u.l.savedpc++);
    StkId ra;
    if ((L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT)) &&
        (--L->hookcount == 0 || L->hookmask & LUA_MASKLINE)) {
      Protect(traceexec(L));
    }
    /* WARNING: several calls may realloc the stack and invalidate `ra' */
    ra = RA(i);
    lua_assert(base == ci->u.l.base);
    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
    vmdispatch (GET_OPCODE(i)) {
      vmcase(OP_NEWTABLE,
        int b = GETARG_B(i);
        int c = GETARG_C(i);
        Table *t = luaH_new(L);
        sethvalue(L, ra, t);
        if (b != 0 || c != 0)
          luaH_resize(L, t, luaO_fb2int(b), luaO_fb2int(c));
        checkGC(L, ra + 1);
      )
    }
  }
}
                        </code></pre>

                        <p class="fragment">A bit confused?</p>
                    </section>

                    <section>
                        <h4>Execute NEWTABLE in Lua VM</h4>
                        <p>We only need to trace the following part of code for the naive example. ;)</p>

                        <pre><code class="c" data-trim>
      vmcase(OP_NEWTABLE,
        // Get the operator B from the instruction
        int b = GETARG_B(i);
        // Get the operator C from the instruction
        int c = GETARG_C(i);
        Table *t = luaH_new(L);
        // Remember this macro: `sethvalue` ? ;)
        sethvalue(L, ra, t);
      )
                        </code></pre>

                        <p class="fragment">Now we only need to look at `<code>luaH_new</code>`. :)</p>
                    </section>

                    <section>
                        <h4>Execute NEWTABLE in Lua VM</h4>

                        <pre><code class="c" data-trim>
Table *luaH_new (lua_State *L) {
  Table *t = &luaC_newobj(L, LUA_TTABLE, sizeof(Table), NULL, 0)->h;
  t->array = NULL;
  t->sizearray = 0;
  setnodevector(L, t, 0);
  return t;
}

static void setnodevector (lua_State *L, Table *t, int size) {
  int lsize;
  if (size == 0) {  /* no elements to hash part? */
    t->node = cast(Node *, dummynode);  /* use common `dummynode' */
    lsize = 0;
  }
  else {
    int i;
    lsize = luaO_ceillog2(size);
    if (lsize > MAXBITS)
      luaG_runerror(L, "table overflow");
    size = twoto(lsize);
    t->node = luaM_newvector(L, size, Node);
    for (i = 0; i < size; i++) {
      Node *n = gnode(t, i);
      gnext(n) = NULL;
      setnilvalue(gkey(n));
      setnilvalue(gval(n));
    }
  }
  t->lsizenode = cast_byte(lsize);
  t->lastfree = gnode(t, size);  /* all positions are free */
}
                        </code></pre>

                        <p class="fragment">Confused by `<code>setnodevector</code>`?</p>
                    </section>

                    <section>
                        <h4>It's simpler in our case...</h4>

                        <pre><code class="c" data-trim>
Table *luaH_new (lua_State *L) {
  Table *t = &luaC_newobj(L, LUA_TTABLE, sizeof(Table), NULL, 0)->h;
  t->array = NULL;
  t->sizearray = 0;
  t->node = cast(Node *, dummynode);  /* use common `dummynode' */
  t->lsizenode = 0;
  t->lastfree = gnode(t, 0);  /* all positions are free */
  return t;
}
                        </code></pre>

                    </section>

                    <section>
                        <h4>What's `<code>dummynode</code>`?</h4>

                        <pre><code class="c" data-trim>
/* macro defining a nil value */
#define NILCONSTANT {NULL}, LUA_TNIL

#define dummynode       (&dummynode_)

#define isdummy(n)      ((n) == dummynode)

static const Node dummynode_ = {
  {NILCONSTANT},  /* value */
  {{NILCONSTANT, NULL}}  /* key */
};
                        </code></pre>

                        <p class="fragment">All empty table in Lua points to the same memory area. CLEVER Lua!</p>
                    </section>

                    <section>
                        <h3>What happens when creating a `<code>Table</code>`?</h3>
                        <h4>What about creating a non-empty table?</h4>
                        <p>We will come back to this topic later. ;)</p>
                    </section>

                    <section>
                        <h3>What happens when accessing a `<code>Table</code>`?</h3>
                    </section>

                    <section>
                        <h3>Another naive example:</h3>

                        <pre><code class="lua" data-trim>
local t = {}
return t[1]
                        </code></pre>

                        <pre><code class="assembly" data-trim>
0+ params, 2 slots, 1 upvalue, 1 local, 1 constant, 0 functions
        1       [1]     NEWTABLE        0 0 0
        2       [2]     GETTABLE        1 0 -1  ; 1
        3       [2]     RETURN          1 2
        4       [2]     RETURN          0 1
                        </code></pre>

                        <p>Instructions related to accessing table:</p>

                        <pre><code class="assembly" data-trim>
        2       [2]     GETTABLE        1 0 -1  ; 1
                        </code></pre>

                    </section>

                    <section>
                        <h4>GETTABLE instruction</h4>

                        <blockquote>
                            GETTABLE A B C R(A) := R(B)[RK(C)]
                        </blockquote>

                        <ul>
                            <li>Copies the value from a table element into register R(A).</li>
                            <li>The table is referenced by register R(B). </li>
                            <li>The index to the table is given by RK(C), which may be the value of register R(C) or a constant number.
                        </ul>

                    </section>

                    <section>
                        <h4>Execute GETTABLE in Lua VM</h4>
                        <p>Look at the for loop in `<code>luaV_execute</code>` (lvm.c):</p>

                        <pre><code class="c" data-trim>
      vmcase(OP_GETTABLE,
        Protect(luaV_gettable(L, RB(i), RKC(i), ra));
      )
                        </code></pre>

                        <p class="fragment">Now we need to look at `<code>luaV_gettable</code>`. :)</p>
                    </section>

                    <section>
                        <h4>Execute GETTABLE in Lua VM</h4>

                        <pre><code class="c" data-trim>
void luaV_gettable (lua_State *L, const TValue *t, TValue *key, TValue *val) {
    // Remember this macro: `ttistable` ? ;)
    if (ttistable(t)) {  /* `t' is a table? */
      // Remember this macro: `hvalue` ? ;)
      Table *h = hvalue(t);
      const TValue *res = luaH_get(h, key); /* do a primitive get */
      // Remember this macro: `ttisnil` ? ;)
      if (!ttisnil(res)) { /* result is not nil? */
        // Remember this macro: `setobj` ? ;)
        setobj(L, val, res);
      }
    }
    return;
}
                        </code></pre>

                        <p class="fragment">Now only the function `<code>luaH_get</code>` causes our headaches.</p>

                    </section>

                    <section>
                        <h4>Dive into `<code>luaH_get</code>`</h4>

                        <pre><code class="c" data-trim>
/*
** main search function
*/
const TValue *luaH_get (Table *t, const TValue *key) {
  switch (ttype(key)) {
    case LUA_TSHRSTR: return luaH_getstr(t, rawtsvalue(key));
    case LUA_TNIL: return luaO_nilobject;
    case LUA_TNUMBER: {
      int k;
      lua_Number n = nvalue(key);
      lua_number2int(k, n);
      if (luai_numeq(cast_num(k), n)) /* index is int? */
        return luaH_getint(t, k);  /* use specialized version */
      /* else go through */
    }
    default: {
      Node *n = mainposition(t, key);
      do {  /* check whether `key' is somewhere in the chain */
        if (luaV_rawequalobj(gkey(n), key))
          return gval(n);  /* that's it */
        else n = gnext(n);
      } while (n);
      return luaO_nilobject;
    }
  }
}
                        </code></pre>
                    </section>

                    <section>
                        <h4>It's simpler in our case...</h4>

                        <pre><code class="c" data-trim>
const TValue *luaH_get (Table *t, const TValue *key) {
  int k;
  // Remember this macro: `nvalue` ? ;)
  lua_Number n = nvalue(key);
  lua_number2int(k, n);
  if (luai_numeq(cast_num(k), n)) /* index is int? */
    return luaH_getint(t, k);  /* use specialized version */
}
                        </code></pre>

                        <p class="fragment">What's the so-called specialized function `<code>luaH_getint</code>`?</p>
                    </section>

                    <section>
                        <h4>Dive into `<code>luaH_get</code>`</h4>

                        <pre><code class="c" data-trim>
/*
** search function for integers
*/
const TValue *luaH_getint (Table *t, int key) {
  /* (1 <= key && key <= t->sizearray) */
  if (cast(unsigned int, key-1) < cast(unsigned int, t->sizearray))
    return &t->array[key-1];
  else {
    lua_Number nk = cast_num(key);
    Node *n = hashnum(t, nk);
    do {  /* check whether `key' is somewhere in the chain */
      if (ttisnumber(gkey(n)) && luai_numeq(nvalue(gkey(n)), nk))
        return gval(n);  /* that's it */
      else n = gnext(n);
    } while (n);
    return luaO_nilobject;
  }
}
                        </code></pre>

                        <ul>
                            <li>If the int key is smaller than the size of array, access the array part.</li>
                            <li>Otherwises, compute the hash value of the key, and access the hash part.</li>
                        </ul>
                    </section>

                    <section>
                        <h4>What does this loop do?</h4>

                        <pre><code class="c" data-trim>
    do {  /* check whether `key' is somewhere in the chain */
      if (ttisnumber(gkey(n)) && luai_numeq(nvalue(gkey(n)), nk))
        return gval(n);  /* that's it */
      else n = gnext(n);
    } while (n);
    return luaO_nilobject;
                        </code></pre>

                    </section>

                    <section>
                        <h4>Dive into `<code>luaH_get</code>`</h4>

                        <p>Lua table uses <b>open addressing</b> to resolve hash collision:</p>

                        <img align="middle" height="500px;" data-src="img/open-addressing.png">
                    </section>

                    <section>
                        <h4>Dive into `<code>luaH_get</code>`</h4>
                        <ul>
                            <li>Lua defines the index of the hash part of table as "mainposition".</li>
                            <li>The rest part of `<code>luaH_get</code>` is similar to `<code>luaH_getint</code>`. XD</li>
                        </ul>
                    </section>

                    <section>
                        <h3>What happens when setting the value of a `<code>Table</code>` element?</h3>
                    </section>

                    <section>
                        <h3>Always naive example :)</h3>

                        <pre><code class="lua" data-trim>
local t = {}
t[1] = 3
                        </code></pre>

                        <pre><code class="assembly" data-trim>
0+ params, 2 slots, 1 upvalue, 1 local, 2 constants, 0 functions
        1       [1]     NEWTABLE        0 0 0
        2       [2]     SETTABLE        0 -1 -2 ; 1 3
        3       [2]     RETURN          0 1
                        </code></pre>

                        <p>Instructions related to accessing table:</p>

                        <pre><code class="assembly" data-trim>
        2       [2]     SETTABLE        0 -1 -2 ; 1 3
                        </code></pre>
                    </section>

                    <section>
                        <h4>SETTABLE instruction</h4>

                        <blockquote>
                            SETTABLE A B C R(A)[RK(B)] := RK(C)
                        </blockquote>

                        <ul>
                            <li>Copies the value from register R(C) or a constant into a table element.</li>
                            <li>The table is referenced by register R(A).</li>
                            <li>The index to the table is given by RK(B), which may be the value of register R(B) or a constant number.
                        </ul>
                    </section>

                    <section>
                        <h4>Execute SETTABLE in Lua VM</h4>
                        <p>Look at the for loop in `luaV_execute` (lvm.c):</p>

                        <pre><code class="c" data-trim>
      vmcase(OP_SETTABLE,
        Protect(luaV_settable(L, ra, RKB(i), RKC(i)));
      )
                        </code></pre>

                        <p class="fragment">It looks like the case of `<code>GETTABLE</code>`. XD</p>
                    </section>

                    <section>
                        <h4>Execute SETTABLE in Lua VM</h4>

                        <p>Now look at function `<code>luaV_settable</code>`:</p>

                        <pre><code class="c" data-trim>
void luaV_settable (lua_State *L, const TValue *t, TValue *key, TValue *val) {
    if (ttistable(t)) {  /*  `t' is a table? */
        Table *h = hvalue(t);
        // Remember `luaH_get`?
        TValue *oldval = cast(TValue *, luaH_get(h, key));
        /*  is there a previous entry in the table? */
        if (!ttisnil(oldval) ||
            /*  no previous entry; must create one. (The next test is
             *              always true; we only need the assignment.) */
            (oldval = luaH_newkey(L, h, key), 1)) {
            /*  (now) there is an entry with given key */
            setobj(L, oldval, val);  /*  assign new value to that entry */
        }
    }
    return;
}
                        </code></pre>

                        <p class="fragment">C trick of comma operator: <code>(a, b, c)</code> is a sequence of expressions, separated by commas, which evaluates to the last expression <code>c</code>.</p>
                    </section>

                    <section>
                        <h4>What does <code>luaV_settable</code> do?</h4>
                        <ol>
                            <li>Get the old value of the key.</li>
                            <li>If
                            <ul>
                                <li>The old value is <code>nil</code>: create a new key by `<code>luaH_newkey</code>` and write the corresponding value.</li>
                                <li>Otherwises, rewrite the value.</li>
                            </ul>
                            </li>
                        </ol>
                    </section>

                    <section>
                        <h4>What does <code>luaH_newkey</code> do?</h4>
                        <pre><code class="c" data-trim>
/*
** inserts a new key into a hash table; first, check whether key's main
** position is free. If not, check whether colliding node is in its main
** position or not: if it is not, move colliding node to an empty place and
** put new key in its main position; otherwise (colliding node is in its main
** position), new key goes to an empty position.
*/
TValue *luaH_newkey (lua_State *L, Table *t, const TValue *key) {
  Node *mp;
  if (ttisnil(key)) luaG_runerror(L, "table index is nil");
  else if (ttisnumber(key) && luai_numisnan(L, nvalue(key)))
    luaG_runerror(L, "table index is NaN");
  mp = mainposition(t, key);
  if (!ttisnil(gval(mp)) || isdummy(mp)) {  /* main position is taken? */
    Node *othern;
    Node *n = getfreepos(t);  /* get a free place */
    if (n == NULL) {  /* cannot find a free place? */
      rehash(L, t, key);  /* grow table */
      /* whatever called 'newkey' take care of TM cache and GC barrier */
      return luaH_set(L, t, key);  /* insert key into grown table */
    }
    lua_assert(!isdummy(n));
    othern = mainposition(t, gkey(mp));
    if (othern != mp) {  /* is colliding node out of its main position? */
      /* yes; move colliding node into free position */
      while (gnext(othern) != mp) othern = gnext(othern);  /* find previous */
      gnext(othern) = n;  /* redo the chain with `n' in place of `mp' */
      *n = *mp;  /* copy colliding node into free pos. (mp->next also goes) */
      gnext(mp) = NULL;  /* now `mp' is free */
      setnilvalue(gval(mp));
    }
    else {  /* colliding node is in its own main position */
      /* new node will go into free position */
      gnext(n) = gnext(mp);  /* chain new position */
      gnext(mp) = n;
      mp = n;
    }
  }
  setobj(L, gkey(mp), key);
  return gval(mp);
}
                        </code></pre>

                        <p class="fragment">Don't be scared, we will take it apart. ;D</p>
                    </section>

                    <section>
                        <h4>The luckiest case</h4>
                        <p>There's free space. The main position has not been occupied. XD</p>

                        <pre><code class="c" data-trim>
TValue *luaH_newkey (lua_State *L, Table *t, const TValue *key) {
  Node *mp;
  mp = mainposition(t, key);
  setobj(L, gkey(mp), key);
  return gval(mp);
}
                        </code></pre>
                    </section>

                    <section>
                        <h4>Case 2</h4>
                        <p>There's free space. The main position has been occupied, and that bad guy is occupying its main position. :|</p>

                        <pre><code class="c" data-trim>
TValue *luaH_newkey (lua_State *L, Table *t, const TValue *key) {
  Node *mp;
  mp = mainposition(t, key);
  if (!ttisnil(gval(mp)) || isdummy(mp)) {  /* main position is taken? */
    Node *othern;
    Node *n = getfreepos(t);  /* get a free place */
    lua_assert(!isdummy(n));
    /* colliding node is in its own main position */
    /* new node will go into free position */
    gnext(n) = gnext(mp);  /* chain new position */
    gnext(mp) = n;
    mp = n;
  }
  setobj(L, gkey(mp), key);
  return gval(mp);
}
                        </code></pre>
                    </section>

                    <section>
                        <h4>Case 3</h4>
                        <p>There's free space. The main position has been occupied, and that bad guy is not occupying its main position. :(</p>

                        <pre><code class="c" data-trim>
TValue *luaH_newkey (lua_State *L, Table *t, const TValue *key) {
  Node *mp;
  mp = mainposition(t, key);
  if (!ttisnil(gval(mp)) || isdummy(mp)) {  /* main position is taken? */
    Node *othern;
    Node *n = getfreepos(t);  /* get a free place */
    lua_assert(!isdummy(n));
    othern = mainposition(t, gkey(mp));
    if (othern != mp) {  /* is colliding node out of its main position? */
      /* yes; move colliding node into free position */
      while (gnext(othern) != mp) othern = gnext(othern);  /* find previous */
      gnext(othern) = n;  /* redo the chain with `n' in place of `mp' */
      *n = *mp;  /* copy colliding node into free pos. (mp->next also goes) */
      gnext(mp) = NULL;  /* now `mp' is free */
      setnilvalue(gval(mp));
    }
  }
  setobj(L, gkey(mp), key);
  return gval(mp);
}

                        </code></pre>
                    </section>

                    <section>
                        <h4>Case 4</h4>
                        <p>There's no free space. :(</p>

                        <p class="fragment">It will cause <b>rehashing</b>.</p>
                        <ul>
                            <li class="fragment">The hash part is full: double the hash part. (Remember the `<code>lsizenode</code>` field of `<code>Table</code>`?)</li>
                            <li class="fragment">The array part may grow (by doubling the size) or shrink (so that at lease half of the array is occupied).</li>
                        </ul>

                        <p class="fragment">I will not show the source code of rehashing in order not to scare you. XD</p>
                    </section>

                    <section>
                        <h3>Back to the topic of creating a non-empty table XD</h3>

                        <p>What's the difference between the following code snippets?</p>

                        <pre><code class="lua" data-trim>
local t = {"e1", "e2", "e3", "e4", "e5"}
                        </code></pre>


                        <pre><code class="lua" data-trim>
local t = {}
t[1] = "e1"
t[2] = "e2"
t[3] = "e3"
t[4] = "e4"
t[5] = "e5"
                        </code></pre>
                    </section>

                    <section>
                        <h3>Counting the occurrences of rehashing:</h3>

                        <p>Zero rehash, resize the array part once at table creation. :)</p>
                        <pre><code class="lua" data-trim>
local t = {"e1", "e2", "e3", "e4", "e5"}
                        </code></pre>


                        <p>Rehash four times at SETTABLE. :(</p>
                        <pre><code class="lua" data-trim>
local t = {}
t[1] = "e1"     -- rehash
t[2] = "e2"     -- rehash
t[3] = "e3"     -- rehash
t[4] = "e4"
t[5] = "e5"     -- rehash
                        </code></pre>

                        <p class="fragment">The rehashing overhead can be much higher if there's lots of small table in your Lua program.</p>
                    </section>

                    <section>
                        <h3>Lesson learned</h3>
                        <p>Prefer this way to avoid initial rehashings of table.</p>
                        <pre><code class="lua" data-trim>
local t = {"e1", "e2", "e3", "e4", "e5"}
                        </code></pre>
                    </section>
                </section>

				<section>
                    <h2>More about table in Lua</h2>
                    <ul>
                        <li>metatable</li>
                        <li>OO in Lua</li>
                        <li>Special table: `<code>{}</code>` (we have meet it), `<code>_ENV</code>`, `<code>_G</code>`, etc.</li>
                        <li>...</li>
                    </ul>
                </section>

				<section>
                    <h2>References</h2>
                    <ul>
                        <li><a href="https://www.lua.org/">Lua official website</a></li>
                        <li>"The Implementation of Lua 5.0" by Roberto Ierusalimschy, Luiz Henrique de Figueiredo, Waldemar Celes</li>
                        <li>"Programming in Lua" by the leading architect of Lua, Roberto Ierusalimschy: <a href="http://www.lua.org/pil/contents.html">First version is free online (Lua 5.0)</a></li>
                        <li>"A No-Frills Introduction to Lua 5.1 VM Instructions" by Kein-Hong Man</li>
                        <li>"Lua Performance Tips" by Roberto Ierusalimschy</li>
                    </ul>
                </section>

                <section>
                    <h2>Backup slides for writing Lua code</h2>
                    <pre><code class="lua" data-trim contenteditable>
                    </code></pre>
                </section>

                <section>
                    <h2>Backup slides for writing c code</h2>
                    <pre><code class="c" data-trim contenteditable>
                    </code></pre>
                </section>

            </div>
        </div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>
			// More info https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				history: true,

				// More info https://github.com/hakimel/reveal.js#dependencies
				dependencies: [
					{ src: 'plugin/markdown/marked.js' },
					{ src: 'plugin/markdown/markdown.js' },
					{ src: 'plugin/notes/notes.js', async: true },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
				]
			});
		</script>
	</body>
</html>
